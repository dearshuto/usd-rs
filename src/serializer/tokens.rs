use phf::phf_map;

#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub enum Token {
    BraceL,
    BraceR,
    BracketL,
    BracketR,
    ParenthesesR,
    ParenthesesL,
    Colon,
    Comma,
    Equal,
    Space,
    Return,
    StringValue(String),
    NumberValue(f64),
    BooleanValue(bool),
    Bool,
    Color3f,
    Color3fArray,
    Float3f,
    Float3fArray,
    Double3f,
    IntArray,
    Point3f,
    Point3fArray,
    Normal3fArray,
    Uniform,
    NullValue,
    Def,
    XformOp,
    XformOpOrder,
    Translate,
    Token,
    Identifier(String),
    Directive(String),
    End,
    Unknown,
}

pub static CHAR_TOKENS: phf::Map<char, Token> = phf_map! {
    '{' => Token::BraceL,
    '}' => Token::BraceR,
    '[' => Token::BracketL,
    ']' => Token::BracketR,
    '(' => Token::ParenthesesL,
    ')' => Token::ParenthesesR,
    ':' => Token::Colon,
    ',' => Token::Comma,
    '=' => Token::Equal,
};

pub static KEYWORD_TOKENS: phf::Map<&'static str, Token> = phf_map! {
    "true" => Token::BooleanValue(true),
    "false" => Token::BooleanValue(false),
    "null" => Token::NullValue,
    "def" => Token::Def,
    "bool" => Token::Bool,
    "color3f" => Token::Color3f,
    "color3f[]" => Token::Color3fArray,
    "translate" => Token::Translate,
    "float3" => Token::Float3f,
    "float3[]" => Token::Float3fArray,
    "double3" => Token::Double3f,
    "int[]" => Token::IntArray,
    "point3f[]" => Token::Point3fArray,
    "normal3f[]" => Token::Normal3fArray,
    "uniform" => Token::Uniform,
    "xformOp" => Token::XformOp,
    "xformOpOrder" => Token::XformOpOrder,
    "token" => Token::Token,
};
